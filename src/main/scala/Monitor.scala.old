

import scala.annotation.tailrec

sealed trait Color

case class Black() extends Color

case class Red() extends Color

case class White() extends Color

case class Pixel(color: Color = Black(), brightness: Int = 0)

// An immutable grid of pixels.
// type PixelGrid = Vector[Vector[Pixel]]

/*
def processArray(arr: RectArray2D[Int, _]) = {
  // Run-time confirmation of what we've verified at compile-time.
  require(arr.rows.map(_.size).distinct.size == 1)
  // Do something.
}

// Compiles and runs.
processArray(RectArray2D(
  Sized( 0,  1,  2,  3),
  Sized(10, 11, 12, 13),
  Sized(20, 21, 22, 23)
))

// Doesn't compile.
processArray(RectArray2D(
  Sized( 0,  1,  2,  3),
  Sized(10, 11, 12),
  Sized(20, 21, 22, 23)
))
 */

import shapeless.Sized
import shapeless.Nat

/**
  *
  * @param columns the variable length collection of columns. The length of each column must equal "Length" for it to compile.
  * @tparam MyLength the length of each column in the grid. Column length corresponds to y-max - 1, column number corresponds to x coordinate.
  */
/*
case class PixelGrid[MyLength <: Nat](columns: Sized[Vector[Pixel], MyLength]*) {

  def verticalAppend[OtherLength, CombinedLength](other: PixelGrid[OtherLength])
  : PixelGrid[CombinedLength] = {
    val otherColumns = other.columns
    require(columns.length == otherColumns.length, "You can only vertical append grids of equal width")
    val accumulator = Seq[Sized[Vector[Pixel], CombinedLength]]()
    for(i <- 0 to columns.length) {
      val appended: Vector[Pixel] = columns(i) ++ otherColumns(i)
      val sizedColumn = Sized( appended )
      accumulator :+ sizedColumn
    }
    PixelGrid(accumulator:_*)
  }
}
*/
/*
implicit class PixelGridWrapper(in: PixelGrid) {

  in.columns(0).unsized.

  require(in.length > 0, "Grids must have a positive number of columns")
  require(in(0).length > 0, "Grids must have a positive number of rows")
  // Note this should probably be verified at compile time
  require(in.map(column => column.length).distinct.size == 1, "each column has have the same length")

  def width = in.length
  def height = in(0).length
  def verticalAppend(above: PixelGrid) = {
    for()
  }
}
*/

abstract class GridTransform(val unitWidth: Int, val unitHeight: Int) extends Function1[PixelGrid, PixelGrid] {
  abstract def apply(v1: PixelGrid): PixelGrid
}

case class Display(width: Int, height: Int) {
  require(width > 0)
  require(height > 0)
  // assume that (0, 0) is thetop left corner.
  val screen: PixelGrid = Vector.fill(width, height)(Pixel()) // first dim width (left-right), second dim height (top-bottom)

  def fillRow(accumulator: Vector[Pixel], xPos: Int): Vector[Pixel] = {
    if(xPos == width)  accumulator
    else  fillRow(accumulator :+ Pixel(), xPos + 1)
  }

  val gcd = greatestCommonDivisor(width, height)
  val aspectRatioWidth = width / gcd
  val aspectRatioHeight = height / gcd
  val aspectRatio = aspectRatioWidth.toDouble / aspectRatioWidth.toDouble


  def resize(transformation: GridTransform): Display = {
    require(transformation.unitWidth <= width, "The unit of transformation cannot be wider than the display")
    require(transformation.unitHeight <= height, "The unit of transformation cannot be taller than the display")
    require(width % transformation.unitWidth == 0, "The transformation's unit width must divide evenly with the display width")
    require(height % transformation.unitHeight == 0, "The transformation's unit height must divide evenly with the display height")
    val subPixelGridTall = screen.slice(0, transformation.unitHeight)
    val subPixelGrid: PixelGrid = Vector[Vector[Pixel]]()
    for(column <- 0 to transformation.unitWidth) {
      subPixelGrid :+ subPixelGridTall(column)
    }
    null
  }

  @tailrec
  private def greatestCommonDivisor(a: Int, b: Int): Int = {
    if (b == 0) a
    else greatestCommonDivisor(b, a % b)
  }

  // done with constructor

}

/**
  * Created by johnreed on 5/11/16.
  */
object Main {

  val intVec = Vector[Int](1, 2, 3, 4, 5, 6, 7, 8)

  def main(args: Array[String]) {

    println(intVec)

    // this code is under the public domain where applicable


  }

}
